/* $Id: timer.c 8438 2009-06-02 14:02:14Z yvoronen $ */
/***************************************************************************
 * SPL Timer								   *
 * main.c								   *
 *									   *
 * This is a timing driver. It calls the subroutines generated by SPL      *
 * compiler and measures clock cycles using RDTSC instruction available    *
 * on Pentium and compatible processors.                                   *
 ***************************************************************************/

#include <limits.h>
#include <time.h>
#include <stdio.h>
#include <stdint.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include "vector.h"
#include "errcodes.h"
#include "opt_macros.h"

extern void INITFUNC(void);

#if (ALLOCATE_MEMORY)
extern void FUNC(double *Y, double *X);
#else
extern void FUNC(void);
#endif

/*	how many cycles should at least pass	*/
#define REQUIRED_CYCLES		1E7


vector_t * Input;
vector_t * Output;

struct rdtsc_timer_config_t {
    int num_runs;
    int verbose;
    int gap_output;
    int processor_freq; /* in MHz */
    int page_size;
    int xofs, xincr, xofs_max;
    int yofs, yincr, yofs_max;
    int mesh;
    int specified_num_runs;
} TimerConfig;

void init_options() {
    TimerConfig.specified_num_runs = 0;
    TimerConfig.num_runs = 100;
    TimerConfig.verbose = 0;
    TimerConfig.gap_output = 0;
    TimerConfig.processor_freq = -1;

    TimerConfig.page_size = 4096;
    TimerConfig.xincr = 8;
    TimerConfig.yincr = 8;
    TimerConfig.xofs = TimerConfig.xofs_max = 0;
    TimerConfig.yofs = TimerConfig.yofs_max = 0;
    
    TimerConfig.mesh = 0;
}

char* usage() {
    return "Usage: test <-freq num> [-v] [-g] [-n num]\n";
} 

void parse_options(int argc, char **argv) 
{
    init_options();

    SHIFT();

    while( argc > 0 && HAS_MINUS(argv[0]) ) 
    {
	    /* common for all timers */
	    if      (OPT("-v"))  sys_set_verbose(1); 
	    else if (OPT("-h") || OPT("--help")) sys_fatal(EXIT_CMDLINE, usage());
	    else if (OPT("-g"))  TimerConfig.gap_output = 1;
	    else if (OPT("-n"))  { GET_INT_ARG(TimerConfig.num_runs); TimerConfig.specified_num_runs = 1; }
	    else if (OPT("-freq")) GET_INT_ARG(TimerConfig.processor_freq)
	    else if (OPT("-page"))  GET_INT_ARG(TimerConfig.page_size)
	    else if (OPT("-xl"))  GET_INT_ARG(TimerConfig.xofs)
	    else if (OPT("-yl"))  GET_INT_ARG(TimerConfig.yofs)
	    else if (OPT("-xh"))  GET_INT_ARG(TimerConfig.xofs_max)
	    else if (OPT("-yh"))  GET_INT_ARG(TimerConfig.yofs_max)
	    else if (OPT("-xi"))  GET_INT_ARG(TimerConfig.xincr)
	    else if (OPT("-yi"))  GET_INT_ARG(TimerConfig.yincr)
    
	    else if (OPT("-mesh"))  TimerConfig.mesh = 1;
	    
	    else sys_fatal(EXIT_CMDLINE, "illegal option '%s'\n", argv[0]);
    
	    SHIFT();
    }
    
    if(TimerConfig.xofs_max < TimerConfig.xofs)  TimerConfig.xofs_max = TimerConfig.xofs;
    if(TimerConfig.yofs_max < TimerConfig.yofs)  TimerConfig.yofs_max = TimerConfig.yofs;

    if(argc > 0) /* garbage at the end remains */
	    sys_fatal(EXIT_CMDLINE, usage());

    if (TimerConfig.num_runs < 1) 
	    sys_fatal(EXIT_CMDLINE, "rdtsc timer: number of runs must be at least 1");
}

void initialize(int argc, char **argv) {
    unsigned long rows, cols, page;
    scalar_type_t *t;

    sys_set_progname(argv[0]);
    srand(time(0));

    parse_options(argc,argv);

    if(TimerConfig.specified_num_runs)
		sys_msg("Number of runs (command line) = %d\n", TimerConfig.num_runs);
    else
   		TimerConfig.specified_num_runs = 1;

    t = scalar_find_type(DATATYPE);
    if(t == NULL)
	    sys_fatal(EXIT_CMDLINE, "Catastrophic error, datatype " DATATYPE " not found");

    page = PAGESIZE;
      
#if (ALLOCATE_MEMORY)
    rows = ROWS;
    cols = COLUMNS;
#else
    rows = 1;
    cols = 1;
#endif

    Output = vector_create_random(t, rows + 1 + ((page + TimerConfig.yofs_max) / t->size));
    Input  = vector_create_zero  (t, cols + 1 + ((page + TimerConfig.xofs_max) / t->size));

/*
    yaddr = (unsigned long)Output->data;
    xaddr = (unsigned long)Input->data;

    sys_msg("x=%x y=%x\n", xaddr, yaddr);
    // align on page boundary
    yaddr = yaddr - (yaddr % page) + page; 
    xaddr = xaddr - (xaddr % page) + page;
    sys_msg("align x=%x y=%x\n", xaddr, yaddr);
    // shift
    yaddr += TimerConfig.yofs;
    xaddr += TimerConfig.xofs;
    sys_msg("shift x=%x y=%x\n", xaddr, yaddr);

    Output->data = (void*) yaddr;
    Input->data = (void*) xaddr;
*/
    return;

    INITFUNC();
}

/* handles wraparound (an unlikely event but still possible. */

#define MAX_UINT64 0xFfffFfffFfffFfff

uint64_t subtract(uint64_t a, uint64_t b)
{
    return (a > b) ? a - b : b + (MAX_UINT64 - a);
}

uint64_t perform_timing(int num_runs) {
    static int run;
    double t;
    uint64_t a, b;

#if (ALLOCATE_MEMORY) 
    static void *in, *out;
#endif

    run = 0;

#if (ALLOCATE_MEMORY) 
    out = Output->data;
    in = Input->data;
#endif

	while(1)
	{
		a = mach_absolute_time();
		for(run = 0; run < num_runs; ++run)
        { 
#if (ALLOCATE_MEMORY) 
            FUNC(out, in);
#else
            FUNC();
#endif
        }
        b = mach_absolute_time();

        t = (double) subtract(b, a);

		if(t >= REQUIRED_CYCLES) break;

		num_runs *= 2;
	}

	/* start of measurement */

    a = mach_absolute_time();

    for(run = 0 ; run < num_runs; ++run) 
    {
#if (ALLOCATE_MEMORY) 
        FUNC(out, in);
#else
        FUNC();
#endif
    }

    b = mach_absolute_time();

    return ((double) subtract(b, a) / (double) num_runs);
}

int main(int argc, char** argv) 
{
    static double cycles;
    static unsigned long xx, yy;
    scalar_type_t *t;
#if (ALLOCATE_MEMORY) 
    static void *out, *in;
#endif

    initialize(argc,argv);

#if (ALLOCATE_MEMORY) 
    out = Output->data;
    in = Input->data;
#endif
    for(xx = TimerConfig.xofs; xx <= TimerConfig.xofs_max; xx += TimerConfig.xincr) 
    {
#if (ALLOCATE_MEMORY) 
	    Output->data = out;
#endif

	    t = scalar_find_type("double");

	    for(yy = TimerConfig.yofs; yy <= TimerConfig.yofs_max; yy += TimerConfig.yincr) 
        {
	        cycles = perform_timing(TimerConfig.num_runs);

	        if(TimerConfig.gap_output) 
            {
		        if(TimerConfig.mesh) 
                {
		            printf("[%lu, %lu, ", xx, yy);
			        t->fprint_gap(t, stdout, &cycles); 
		            printf("],\n");
		        } else {
		            t->fprint_gap(t, stdout, &cycles); 
		            printf(";\n");
		        }
	        } else {
		        if(TimerConfig.mesh)
		            printf("%lu %lu %e;\n", xx, yy, cycles);
		        else 
                    printf("%e;\n", cycles);
	        }

	        Output->data = (void*)( (unsigned long)Output->data + TimerConfig.yincr);
	    }

	    Input->data = (void*)( (unsigned long)Input->data + TimerConfig.xincr);
    }

    return EXIT_SUCCESS;
}
