Search Module
=============

The search module uses different
search algorithms to find fast implementations of transforms.

- ExhaustiveSearch() -- measure all possible ruletrees.
- DP()               -- performs dynamic programming.
- RandomSearch()     -- generates random ruletrees, searching for the fastest.


General Search Options
----------------------
 
These search options are common to many of the algorithms:
```
  timeLimit := false | <minutes>,
  globalUnrolling := true | false,
  globalUnrollingMin := <positive int>,
  globalUnrollingMax := <positive int>,
  bestFound := "save" | "none"
```

Time limit specifies the maximum number of minutes that a search 
algorithm should continue searching.  Setting this to false allows the
search algorithm to continue searching until it is finished.  Most, but
not all, search algorithms (notably not DP) can give back a reasonable
result after any amount of time.  Since GAP does not have an interrupt
mechanism, it is quite possible for a search algorithm to take
considerably more time than specified.  A check on time is only
conducted at certain points in the loops/recursion of the search
algorithms.

Global unrolling specifies to the SPL compiler that ALL nodes of the
given size and smaller are to be unrolled.

Setting globalUnrolling to true causes the search algorithms to search
over different settings for the global unrolling.  Specifically they
search from globalUnrollingMin to globalUnrollingMax, inclusive, going
by factors of 2 (that is, they consider globalUnrollingMin,
globalUnrollingMin*2, globalUnrollingMin*4, etc ... until
globalUnrollingMin*2^k > globalUnrollingMax).


Setting bestFound to "save" causes the search modules to try to save
their best found implementations for spls into the BestFoundTable.
If they did not find one faster than previously found, then nothing
happens.  Setting bestFound to "none" causes the search modules to do
nothing with the BestFoundTable.


ExhaustiveSearch
----------------
 
Usage: ```ExhaustiveSearch( <spl> [, <Exhaustive-Search-options-record>, <SPLOptionsRecord> ] )```

Note that if you wish to specify an Exhaustive-options-record or a
SPL-options-record, then you must specify both.  To leave one blank,
just pass "rec()" in its place.

Searches over all possible ruletrees and returns the one with the
fastest runtime.  Currently does NOT search over local or global unrolling
parameters, just different ruletrees.

Returns:  fastest ruletree

### Options
```
spiral> PrintSpecExhaustiveSearchOptionsRecord();             
rec(
  timeLimit := false | <minutes>,
  bestFound := "save" | "none",
  verbosity := <non-negative integer>
);
```
Run ```MergeExhaustiveSearchOptionsRecord( rec() );``` to determine
defaults.

### Verbosity Levels
```
   0 = Print nothing
   1 = Pretty print final best tree
   2 = Also print how many measurements to do
   3 = Print all trees as measured
```

### Examples
```
spiral> W := SPLNonTerminal("WHT", 3);;
spiral> ExhaustiveSearch(W);
#I no. trees: 1 3 3 3 3 3 
#I 3 measurements to do

Best Rule Tree:
WHT(3)     {RuleWHT_1}
 |--WHT(1)     {RuleWHT_0}
 `--WHT(2)     {RuleWHT_1}
     |--WHT(1)     {RuleWHT_0}
     `--WHT(1)     {RuleWHT_0}
 ! 215

RuleTree(
  RuleWHT_1,
  SPLNonTerminal( "WHT", 3 ), [
  RuleTree(RuleWHT_0, SPLNonTerminal( "WHT", 1 )),
  RuleTree(
    RuleWHT_1,
    SPLNonTerminal( "WHT", 2 ), [
    RuleTree(RuleWHT_0, SPLNonTerminal( "WHT", 1 )),
    RuleTree(RuleWHT_0, SPLNonTerminal( "WHT", 1 ))
  ] )
] )
spiral> ExhaustiveSearch( W, rec(verbosity:=1), rec(language:="c") );;
#I no. trees: 1 3 3 3 3 3 

Best Rule Tree:
WHT(3)     {RuleWHT_1}
 |--WHT(1)     {RuleWHT_0}
 `--WHT(2)     {RuleWHT_1}
     |--WHT(1)     {RuleWHT_0}
     `--WHT(1)     {RuleWHT_0}
 ! 216

spiral> 
```

DP (Dynamic Programming)
------------------------

Usage: ```DP( <spl> [, <DP-options-record>, <SPL-options-record> ] )```

Note that if you wish to specify a DP-options-record or a SPL-options-record,
then you must specify both.  To leave one blank, just pass "rec()" in its
place.

DP() runs dynamic programming on the given spl.  Specifically, dynamic
programming considers all applicable rules to the given transform, and
all possible sets of children generated by those rules.  For each child,
it looks up in its table the fastest implementation of that transform.
If no such entry exists yet in its table, then DP recursively calls
itself on the child.  Once DP has found the best implementation for the
child, it substitutes this ruletree in as a subtree of the root in place
of the child.  DP then times all such trees, determines the fastest one,
and enters that in its table.

Returns: List of records.  Each record contains a ruletree and the measured
time for that ruletree.  Fastest ruletree is first entry in the list.  The
list has <nBest> many entries, from the fastest to the nBest fastest formulas
found.

### Options
```
spiral> PrintSpecDPOptionsRecord();
rec(
  timeLimit := false | <minutes>,
  localUnrolling := true | false,
  localUnrollingMin := <positive int>,
  localUnrollingMax := <positive int>,
  globalUnrolling := true | false,
  globalUnrollingMin := <positive int>,
  globalUnrollingMax := <positive int>,
  bestFound := "save" | "none",
  nBest := <positive integer>,
  optimize := "minimize" | "maximize",
  hashTable := <hashTable>,
  verbosity := <non-negative integer>
);
```
Run 'MergeDPOptionsRecord( rec() );' to determine defaults.

An nBest of 1 is the "standard" DP.  Increasing nBest causes DP to not
only keep in its list the best implementation for each spl and size,
but the nBest such implementations.

By setting optimize to "maximize" it is possible to cause DP to maximize
the measured event instead of the usual minimization.

DP uses a hash table to store its list of best implementations.  It is
possible to pass a hash table to DP for it to use and so that you can
keep the resulting hash table when DP finishes.  Note that any entries
in the hashTable will be assumed to the best implementations by DP.
You can create a new hashTable for use with DP by calling HashTableDP().

### Verbosity Levels
```
   0 = Print nothing
   1 = Show recursive calls to DP
   2 = Show best trees found found each recursive call to DP
   3 = Show how many trees must be fully expanded and how many were timed
   4 = Show formulas that are being timed.
```

### Examples
```
spiral> DP( SPLNonTerminal("DCT2", 4) );   
DP called on SPLNonTerminal( "DCT2", 4 )
1 tree(s) to fully expand
  DP called on SPLNonTerminal( "DCT2", 2 )
  1 tree(s) to fully expand
  1 tree(s) timed at this level
  Best Trees:
     DCT2(2)     {RuleDCT2_0} ! 67
  DP called on SPLNonTerminal( "DCT4", 2 )
  1 tree(s) to fully expand
  1 tree(s) timed at this level
  Best Trees:
     DCT4(2)     {RuleDCT4_0} ! 84
1 tree(s) timed at this level
Best Trees:
   DCT2(4)     {RuleDCT2_2}
    |--DCT2(2)     {RuleDCT2_0}
    `--DCT4(2)     {RuleDCT4_0} ! 124
3 total trees timed
[ rec(
      ruletree := RuleTree(
          RuleDCT2_2,
          SPLNonTerminal( "DCT2", 4 ), [
          RuleTree(RuleDCT2_0, SPLNonTerminal( "DCT2", 2 )),
          RuleTree(RuleDCT4_0, SPLNonTerminal( "DCT4", 2 ))
        ] ),
      measured := 124 ) ]
```

```
spiral> DP( SPLNonTerminal("DCT4", 4), rec(nBest:=2), rec() );
DP called on SPLNonTerminal( "DCT4", 4 )
10 tree(s) to fully expand
  DP called on SPLNonTerminal( "DCT2", 4 )
  1 tree(s) to fully expand
    DP called on SPLNonTerminal( "DCT2", 2 )
    1 tree(s) to fully expand
    1 tree(s) timed at this level
    Best Trees:
       DCT2(2)     {RuleDCT2_0} ! 67
    DP called on SPLNonTerminal( "DCT4", 2 )
    1 tree(s) to fully expand
    1 tree(s) timed at this level
    Best Trees:
       DCT4(2)     {RuleDCT4_0} ! 83
  1 tree(s) timed at this level
  Best Trees:
     DCT2(4)     {RuleDCT2_2}
      |--DCT2(2)     {RuleDCT2_0}
      `--DCT4(2)     {RuleDCT4_0} ! 124
  DP called on SPLNonTerminal( "DST2", 2 )
  1 tree(s) to fully expand
  1 tree(s) timed at this level
  Best Trees:
     DST2(2)     {RuleDST2_0} ! 65
  DP called on SPLNonTerminal( "DST4", 2 )
  1 tree(s) to fully expand
  1 tree(s) timed at this level
  Best Trees:
     DST4(2)     {RuleDST4_0} ! 83
  DP called on SPLNonTerminal( "DCT3", 4 )
  1 tree(s) to fully expand
    DP called on SPLNonTerminal( "DCT3", 2 )
    1 tree(s) to fully expand
    1 tree(s) timed at this level
    Best Trees:
       DCT3(2)     {RuleDCT2_0 ^ T} ! 73
  1 tree(s) timed at this level
  Best Trees:
     DCT3(4)     {RuleDCT2_2 ^ T}
      |--DCT3(2)     {RuleDCT2_0 ^ T}
      `--DCT4(2)     {RuleDCT4_0} ! 135
  DP called on SPLNonTerminal( "DST3", 2 )
  1 tree(s) to fully expand
  1 tree(s) timed at this level
  Best Trees:
     DST3(2)     {RuleDST2_0 ^ T} ! 70
10 tree(s) timed at this level
Best Trees:
   DCT4(4)     {RuleDCT4_5 ^ T} ! 162
   DCT4(4)     {RuleDCT4_3}
    |--DCT2(2)     {RuleDCT2_0}
    `--DST2(2)     {RuleDST2_0} ! 170
18 total trees timed
[ rec(
      ruletree := RuleTree(RuleDCT4_5, "T", SPLNonTerminal( "DCT4", 4 )),
      measured := 162 ), rec(
      ruletree := RuleTree(
          RuleDCT4_3,
          SPLNonTerminal( "DCT4", 4 ), [
          RuleTree(RuleDCT2_0, SPLNonTerminal( "DCT2", 2 )),
          RuleTree(RuleDST2_0, SPLNonTerminal( "DST2", 2 ))
        ] ),
      measured := 170 ) ]
spiral> 
```

RandomSearch
------------
 
Usage: ```RandomSearch( <spl> [, <RandomSearch-options-record>, <SPL-options-record> ] )```

Note that if you wish to specify a RandomSearch-options-record or a
SPL-options-record, then you must specify both.  To leave one blank,
just pass "rec()" in its place.

RandomSearch generates random ruletrees and times them, keeping track of
the fastest one it has found so far.  Technically, RandomSearch() is just
a front in to STEER(), passing the correct options to only generate and
time random formulas.

Returns: The fastest implementation found as an "individual" which is a 
record consisting of fields for a ruletree, SPLOptions, the measured event
(usually runtime), and a few other fields not of importance.

### Options
```
spiral> PrintSpecRandomSearchOptionsRecord();
rec(
  numFormulas := <positive integer>
  seed        := <integer>
  timeLimit := false | <minutes>,
  localUnrolling := true | false,
  localUnrollingMin := <positive int>,
  localUnrollingMax := <positive int>,
  globalUnrolling := true | false,
  globalUnrollingMin := <positive int>,
  globalUnrollingMax := <positive int>,
  bestFound := "save" | "none",
  verbosity   := <non-negative integer>
);
```
Run 'MergeRandomSearchOptionsRecord( rec() );' to determine defaults.

numFormulas specifies how many random formulas to generate.  Note that is
possible that RandomSearch will not time this many formulas as it will not
time the exact same formula twice.

seed specifies a random seed for use with the random number generator.

### Verbosity Levels
```
   0 = Print nothing
   1 = Print final best
   2 = Print formulas being timed
```

### Example

```
spiral> RandomSearch( SPLNonTerminal("DFT",16), rec(numFormulas:=10), 
> rec(globalUnrolling:=8) );

Summary:
  Indiv 1: DFT(16)     {RuleDFT_1}
             |--DFT(4)     {RuleDFT_1 ^ T}
             |   |--DFT(2)     {RuleDFT_0}
             |   `--DFT(2)     {RuleDFT_0}
             `--DFT(4)     {RuleDFT_1}
                 |--DFT(2)     {RuleDFT_0}
                 `--DFT(2)     {RuleDFT_0} ! 2861
rec(
  IsIndiv := true,
  operations := IndivOps,
  ruletree := RuleTree(
      RuleDFT_1,
      SPLNonTerminal( "DFT", 16 ), [
      RuleTree(
        RuleDFT_1, "T",
        SPLNonTerminal( "DFT", 4 ), [
        RuleTree(RuleDFT_0, SPLNonTerminal( "DFT", 2 )),
        RuleTree(RuleDFT_0, SPLNonTerminal( "DFT", 2 ))
      ] ),
      RuleTree(
        RuleDFT_1,
        SPLNonTerminal( "DFT", 4 ), [
        RuleTree(RuleDFT_0, SPLNonTerminal( "DFT", 2 )),
        RuleTree(RuleDFT_0, SPLNonTerminal( "DFT", 2 ))
      ] )
    ] ),
  SPLOpts := rec(
      dataType := "complex",
      globalUnrolling := 8,
      language := "fortran",
      compflags := "'-O -fomit-frame-pointer -malign-double'" ),
  measured := 2861,
  fitness := 1/2861 )
spiral>
```



Hash Tables
-----------

Hash tables are efficient ways to store certain types of data.  They are
used in several places in the search module.  For example, the
BestFoundTable is implemented as a HashTable with particular wrapper
functions.  Also, DP and STEER use HashTables to store partial results.
These hash tables can be saved to files and later reused to avoid
duplicating work already done by the search algorithms.

In particular, DP uses a HashTable to store the nBest ruletrees that it
has found for a given spl.  STEER uses a HashTable to store entire
implementations to avoid re-running the same implementation multiple
times.

The most common reason why you would want to use HashTables is to save
DP's partial results.  This is particularly useful, if, for example, you
run DP on a transform of a particular size, but later may want to run DP
on a larger size of that transform.  By saving off DP's HashTable and
then later reusing it, DP can avoid duplicating its earlier work.  An
example is shown below.


### HashSave()

Usage: ```HashSave( HashTable, filename )```

Saves the given HashTable to the specified filename (given as a string).
This allows later retrieval of the HashTable.


### HashRead()

Usage: ```HashRead( filename )```

Returns the HashTable that was stored in the specified file (filename
should be passed as a string).


### HashTable Creation


- **HashTableDP()** creates a HashTable for use with DP.
- **HashTableSTEER()** creates a HashTable for use with STEER.


### Example

```
spiral> myHashTable := HashTableDP();
HashTable
spiral> DP( Transform("DFT",32), rec(hashTable:=myHashTable), rec() );
...
spiral> HashSave( myHashTable, "DP_DFT32.hash" );
spiral> quit;
$ 
...
spiral> myHashTable := HashRead( "DP_DFT32.hash" );
HashTable
spiral> DP( Transform("DFT",1024), rec(hashTable:=myHashTable), rec() );
...
```

BestFoundTable
--------------

The BestFoundTable keeps track of the best found implementations for the
different SPLs.  The search algorithms will save the best
implementations that they find to the BestFoundTable.  Currently, none
of the search algorithms use the table to guide their search.

You can interact with the BestFoundTable using the following functions:


### BestFoundLookup()
 

Usage: ```BestFoundLookup( <spl> [, <SPL-options-record>] )```

Looks up the best found implementation for the given spl.

Returns: a list of BestFoundImpl records consisting of the ruletree, the
actual full SPLOptions, and the measured time.

If no SPL-options-record is passed, then BestFoundLookup returns a list
of the (equally) fastest implementations across all possible SPL Options
(such as language or dataType).  That is, if there is a BestFound
Implementation for the given spl in both C and Fortran, it will only
return the one that is fastest, unless they are equally fast in which
case both will be returned.

If an SPL-options-record IS passed, then BestFoundLookup returns a list 
of the (equally) fastest implementations across only those
implementations having the same values for the SPL Options listed in the
variable BestFoundDifferFields.  By default, BestFoundDifferFields
includes the fields "dataType" and "language".

So, if you want to get the BestFound Implementation for a DFT of size 16
implemented in C (but irrespective of the used dataType), try:
   BestFoundLookup( Transform("DFT",16), rec(language:="c") );


### BestFoundSave()
 

Usage: ```BestFoundSave( filename )```

Saves the BestFoundTable to the specified filename (given as a string).
This allows later retrieval of the Table.


### BestFoundRead()
 

Usage: ```BestFoundRead( filename )```

Reads the BestFoundTable in the specified filename (given as a string).
This overwrites (without saving) the current BestFoundTable.  In case of
error in reading the file, the current BestFoundTable is not overwritten.
